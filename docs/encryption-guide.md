Sistema de Encriptación de Extremo a Extremo (E2EE) - Documentación Completa
Introducción y Filosofía
Este documento describe la implementación completa del sistema de encriptación de extremo a extremo en nuestra aplicación de magia. El objetivo principal es proteger el conocimiento y secretos de los magos, asegurando que solo las personas autorizadas puedan acceder a la información sensible.
La arquitectura está diseñada para que ni siquiera los administradores de la base de datos puedan ver el contenido sin dejar un rastro auditable. Cada usuario genera su propio par de claves criptográficas, y todo el contenido sensible se cifra antes de salir del dispositivo del usuario.
Arquitectura de Archivos
El sistema se organiza en varios módulos especializados que trabajan en conjunto:
El archivo hooks/useEncryption.ts actúa como la interfaz principal para todas las operaciones criptográficas. Este hook gestiona la generación de claves, el cifrado y descifrado de datos, y mantiene el estado de las claves del usuario en memoria durante la sesión.
El servicio central services/CryptoService.ts implementa las operaciones criptográficas usando la biblioteca libsodium. Esta biblioteca fue elegida por su seguridad probada y su implementación de algoritmos modernos como X25519 para intercambio de claves y XChaCha20-Poly1305 para cifrado autenticado.
Para la gestión de contenido compartido, services/encryptedContentService.ts proporciona métodos de alto nivel para leer contenido propio o compartido, compartir con otros usuarios, y revocar accesos. Este servicio abstrae la complejidad de recifrar contenido para múltiples destinatarios.
El manejo de archivos multimedia se realiza a través de utils/fileEncryption.ts, que implementa un sistema de cifrado por chunks para manejar archivos grandes de manera eficiente, dividiendo los archivos en bloques de 1MB que se cifran individualmente.
Estructura de Base de Datos
La base de datos está diseñada con varias capas de seguridad y validación:
Las tablas principales de contenido (techniques, gimmicks, magic_tricks, scripts) contienen un campo booleano is_encrypted que indica si el contenido está protegido. Cuando este campo es verdadero, los campos sensibles contienen el marcador "[ENCRYPTED]" en lugar del contenido real.
La tabla encrypted_content es el corazón del sistema, almacenando los metadatos de cifrado. Contiene campos JSONB que guardan los datos realmente cifrados, tanto para campos de texto como para referencias a archivos. Esta separación permite que las consultas y filtros funcionen normalmente sobre las tablas principales sin exponer información sensible.
Para archivos multimedia, la tabla encrypted_files almacena metadatos como el nombre original, tipo MIME, tamaño y número de chunks. La tabla encrypted_file_keys guarda las claves de cifrado del archivo, una por cada usuario autorizado, permitiendo acceso granular sin necesidad de recifrar el archivo completo.
El sistema de compartición utiliza la tabla shared_content, donde se almacenan versiones recifradas del contenido para usuarios específicos. Esto permite compartir sin revelar la clave privada del autor original.
Para la administración y cumplimiento, la tabla profiles incluye campos especiales para administradores: is_admin para marcar cuentas administrativas y admin_recovery_key para acceso de emergencia. Todos los accesos administrativos se registran obligatoriamente en admin_access_logs.
Flujos de Operación
El proceso de creación de contenido cifrado sigue estos pasos: Primero, el usuario debe tener configurado su par de claves criptográficas. Si no las tiene, el sistema las genera automáticamente usando el generador de números aleatorios criptográficamente seguro de libsodium. Luego, todos los campos marcados como sensibles se cifran con la clave pública del usuario. Los campos cifrados se almacenan en la tabla encrypted_content con el ID del contenido que se va a crear. Finalmente, se crea el registro en la tabla principal con los campos sensibles conteniendo "[ENCRYPTED]".
Para archivos, el proceso es más complejo: El archivo se divide en chunks de 1MB, cada chunk se cifra individualmente con una clave simétrica única, la clave simétrica se cifra con la clave pública del usuario, y tanto los chunks cifrados como los metadatos se almacenan en Supabase Storage.
La lectura de contenido verifica primero si el usuario es el propietario o tiene acceso compartido. Para contenido propio, se obtienen los datos cifrados de encrypted_content y se descifran con la clave privada del usuario. Para contenido compartido, se busca en shared_content los datos recifrados específicamente para ese usuario.
El sistema de compartición permite que un propietario comparta su contenido: Primero descifra el contenido con su clave privada, luego obtiene la clave pública del destinatario desde su perfil, recifra el contenido con esa clave pública, y guarda la versión recifrada en shared_content con los permisos apropiados.
Implementación por Tipo de Contenido
Para técnicas (techniques), se cifran los campos name, description, notes, y special_materials. Los archivos image_url y video_url también se protegen. La validación se realiza mediante el trigger validate_technique_encryption.
Los gimmicks protegen name, description, secret_description, instructions, y notes. Los archivos incluyen image_url, video_url, y craft_video_url para el video de construcción.
Los trucos de magia (magic_tricks) cifran title, effect, secret, y cualquier nota adicional. Se protegen tres tipos de archivos: photo_url, effect_video_url, y secret_video_url.
Los scripts asociados a trucos cifran el campo content completo, manteniendo la relación con el truco original a través de trick_id.
Sistema de Mensajería Cifrada
Los mensajes directos implementarán cifrado por conversación. Cada mensaje se cifrará con las claves públicas de todos los participantes de la conversación. La estructura será similar a shared_content pero optimizada para mensajería, con una tabla encrypted_messages que contendrá el mensaje cifrado para cada destinatario.
Gestión de Compras
Cuando un usuario compra contenido protegido, el sistema automáticamente ejecuta el proceso de compartición. El vendedor no necesita intervenir; el sistema recifra el contenido para el comprador y registra la transacción en la tabla purchases mientras crea el acceso en shared_content.
Sistema de Reportes y Acceso Administrativo
Para situaciones que requieran moderación, los administradores tienen un acceso especial pero auditado. La función get_content_for_admin() requiere que el administrador proporcione una razón válida para acceder al contenido. Cada acceso queda registrado permanentemente en admin_access_logs con timestamp, ID del admin, contenido accedido, y razón proporcionada.
El sistema está diseñado para que incluso los administradores no puedan acceder al contenido sin dejar rastro, proporcionando transparencia y responsabilidad en el manejo de información sensible.
Funciones SQL Críticas
La función create_encrypted_technique() maneja la creación atómica de técnicas cifradas, asegurando que tanto los metadatos de cifrado como el contenido se creen en una sola transacción. Esto evita problemas con el trigger de validación que verifica la existencia de metadatos de cifrado.
Funciones similares existen para cada tipo de contenido: create_encrypted_gimmick(), create_encrypted_magic_trick(), y create_encrypted_script().
Para acceso administrativo, get_content_for_admin() implementa los controles y auditoría necesarios, verificando permisos y registrando cada acceso antes de proporcionar los datos solicitados.
Consideraciones de Seguridad
El sistema utiliza algoritmos criptográficos modernos y probados. Las claves privadas nunca se transmiten ni almacenan en el servidor. Todo el cifrado ocurre en el dispositivo del usuario antes de enviar datos a la red. Los archivos grandes se manejan eficientemente sin comprometer la seguridad mediante cifrado por chunks.
La separación entre datos cifrados y metadatos permite que las funciones de búsqueda y filtrado operen normalmente sin exponer información sensible. Los triggers de base de datos aseguran la integridad referencial entre contenido y sus metadatos de cifrado.
Futuras Extensiones
El sistema está diseñado para ser extensible. Futuras mejoras podrían incluir cifrado de grupo para comunidades de magos, rotación automática de claves para seguridad adicional, y sistemas de recuperación de cuenta más sofisticados que mantengan la seguridad del contenido cifrado